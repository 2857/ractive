<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test&#x2F;vendor&#x2F;jslitmus.js - Anglebars</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Anglebars"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Anglebars.html">Anglebars</a></li>
            
                <li><a href="..&#x2F;classes/views.Attribute.html">views.Attribute</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Anglebars.html">Anglebars</a></li>
            
                <li><a href="..&#x2F;modules/views.html">views</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: test&#x2F;vendor&#x2F;jslitmus.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; JSLitmus.js
&#x2F;&#x2F;
&#x2F;&#x2F; Copyright (c) 2010, Robert Kieffer, http:&#x2F;&#x2F;broofa.com
&#x2F;&#x2F; Available under MIT license (http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MIT_License)

(function() {
  &#x2F;&#x2F; Private methods and state

  &#x2F;&#x2F; Get platform info but don&#x27;t go crazy trying to recognize everything
  &#x2F;&#x2F; that&#x27;s out there.  This is just for the major platforms and OSes.
  var platform = &#x27;unknown platform&#x27;, ua = navigator.userAgent;

  &#x2F;&#x2F; Detect OS
  var oses = [&#x27;Windows&#x27;,&#x27;iPhone OS&#x27;,&#x27;(Intel |PPC )?Mac OS X&#x27;,&#x27;Linux&#x27;].join(&#x27;|&#x27;);
  var pOS = new RegExp(&#x27;((&#x27; + oses + &#x27;) [^ \);]*)&#x27;).test(ua) ? RegExp.$1 : null;
  if (!pOS) pOS = new RegExp(&#x27;((&#x27; + oses + &#x27;)[^ \);]*)&#x27;).test(ua) ? RegExp.$1 : null;

  &#x2F;&#x2F; Detect browser
  var pName = &#x2F;(Chrome|MSIE|Safari|Opera|Firefox)&#x2F;.test(ua) ? RegExp.$1 : null;

  &#x2F;&#x2F; Detect version
  var vre = new RegExp(&#x27;(Version|&#x27; + pName + &#x27;)[ \&#x2F;]([^ ;]*)&#x27;);
  var pVersion = (pName &amp;&amp; vre.test(ua)) ? RegExp.$2 : null;
  var platform = (pOS &amp;&amp; pName &amp;&amp; pVersion) ? pName + &#x27; &#x27;  + pVersion + &#x27; on &#x27; + pOS : &#x27;unknown platform&#x27;;

  &#x2F;**
  * A smattering of methods that are needed to implement the JSLitmus testbed.
  *&#x2F;
  var jsl = {
    &#x2F;**
    * Enhanced version of escape()
    *&#x2F;
    escape: function(s) {
      s = s.replace(&#x2F;,&#x2F;g, &#x27;\\,&#x27;);
      s = escape(s);
      s = s.replace(&#x2F;\+&#x2F;g, &#x27;%2b&#x27;);
      s = s.replace(&#x2F; &#x2F;g, &#x27;+&#x27;);
      return s;
    },

    &#x2F;**
    * Get an element by ID.
    *&#x2F;
    $: function(id) {
      return document.getElementById(id);
    },

    &#x2F;**
    * Null function
    *&#x2F;
    F: function() {},

    &#x2F;**
    * Set the status shown in the UI
    *&#x2F;
    status: function(msg) {
      var el = jsl.$(&#x27;jsl_status&#x27;);
      if (el) el.innerHTML = msg || &#x27;&#x27;;
    },

    &#x2F;**
    * Convert a number to an abbreviated string like, &quot;15K&quot; or &quot;10M&quot;
    *&#x2F;
    toLabel: function(n) {
      if (n == Infinity) {
        return &#x27;Infinity&#x27;;
      } else if (n &gt; 1e9) {
        n = Math.round(n&#x2F;1e8);
        return n&#x2F;10 + &#x27;B&#x27;;
      } else if (n &gt; 1e6) {
        n = Math.round(n&#x2F;1e5);
        return n&#x2F;10 + &#x27;M&#x27;;
      } else if (n &gt; 1e3) {
        n = Math.round(n&#x2F;1e2);
        return n&#x2F;10 + &#x27;K&#x27;;
      }
      return n;
    },

    &#x2F;**
    * Copy properties from src to dst
    *&#x2F;
    extend: function(dst, src) {
      for (var k in src) dst[k] = src[k]; return dst;
    },

    &#x2F;**
    * Like Array.join(), but for the key-value pairs in an object
    *&#x2F;
    join: function(o, delimit1, delimit2) {
      if (o.join) return o.join(delimit1);  &#x2F;&#x2F; If it&#x27;s an array
      var pairs = [];
      for (var k in o) pairs.push(k + delimit1 + o[k]);
      return pairs.join(delimit2);
    },

    &#x2F;**
    * Array#indexOf isn&#x27;t supported in IE, so we use this as a cross-browser solution
    *&#x2F;
    indexOf: function(arr, o) {
      if (arr.indexOf) return arr.indexOf(o);
      for (var i = 0; i &lt; this.length; i++) if (arr[i] === o) return i;
      return -1;
    }
  };

  &#x2F;**
  * Test manages a single test (created with
  * JSLitmus.test())
  *
  * @private
  *&#x2F;
  var Test = function (name, f) {
    if (!f) throw new Error(&#x27;Undefined test function&#x27;);
    if (!&#x2F;function[^\(]*\(([^,\)]*)&#x2F;.test(f.toString())) {
      throw new Error(&#x27;&quot;&#x27; + name + &#x27;&quot; test: Test is not a valid Function object&#x27;);
    }
    this.loopArg = RegExp.$1;
    this.name = name;
    this.f = f;
  };

  jsl.extend(Test, &#x2F;** @lends Test *&#x2F; {
    &#x2F;** Calibration tests for establishing iteration loop overhead *&#x2F;
    CALIBRATIONS: [
      new Test(&#x27;calibrating loop&#x27;, function(count) {while (count--);}),
      new Test(&#x27;calibrating function&#x27;, jsl.F)
    ],

    &#x2F;**
    * Run calibration tests.  Returns true if calibrations are not yet
    * complete (in which case calling code should run the tests yet again).
    * onCalibrated - Callback to invoke when calibrations have finished
    *&#x2F;
    calibrate: function(onCalibrated) {
      for (var i = 0; i &lt; Test.CALIBRATIONS.length; i++) {
        var cal = Test.CALIBRATIONS[i];
        if (cal.running) return true;
        if (!cal.count) {
          cal.isCalibration = true;
          cal.onStop = onCalibrated;
          &#x2F;&#x2F;cal.MIN_TIME = .1; &#x2F;&#x2F; Do calibrations quickly
          cal.run(2e4);
          return true;
        }
      }
      return false;
    }
  });

  jsl.extend(Test.prototype, {&#x2F;** @lends Test.prototype *&#x2F;
    &#x2F;** Initial number of iterations *&#x2F;
    INIT_COUNT: 10,
    &#x2F;** Max iterations allowed (i.e. used to detect bad looping functions) *&#x2F;
    MAX_COUNT: 1e9,
    &#x2F;** Minimum time a test should take to get valid results (secs) *&#x2F;
    MIN_TIME: .5,

    &#x2F;** Callback invoked when test state changes *&#x2F;
    onChange: jsl.F,

    &#x2F;** Callback invoked when test is finished *&#x2F;
    onStop: jsl.F,

    &#x2F;**
     * Reset test state
     *&#x2F;
    reset: function() {
      delete this.count;
      delete this.time;
      delete this.running;
      delete this.error;
    },

    &#x2F;**
    * Run the test (in a timeout). We use a timeout to make sure the browser
    * has a chance to finish rendering any UI changes we&#x27;ve made, like
    * updating the status message.
    *&#x2F;
    run: function(count) {
      count = count || this.INIT_COUNT;
      jsl.status(this.name + &#x27; x &#x27; + count);
      this.running = true;
      var me = this;
      setTimeout(function() {me._run(count);}, 200);
    },

    &#x2F;**
     * The nuts and bolts code that actually runs a test
     *&#x2F;
    _run: function(count) {
      var me = this;

      &#x2F;&#x2F; Make sure calibration tests have run
      if (!me.isCalibration &amp;&amp; Test.calibrate(function() {me.run(count);})) return;
      this.error = null;

      try {
        var start, f = this.f, now, i = count;

        &#x2F;&#x2F; Start the timer
        start = new Date();

        &#x2F;&#x2F; Now for the money shot.  If this is a looping function ...
        if (this.loopArg) {
          &#x2F;&#x2F; ... let it do the iteration itself
          f(count);
        } else {
          &#x2F;&#x2F; ... otherwise do the iteration for it
          while (i--) f();
        }

        &#x2F;&#x2F; Get time test took (in secs)
        this.time = Math.max(1,new Date() - start)&#x2F;1000;

        &#x2F;&#x2F; Store iteration count and per-operation time taken
        this.count = count;
        this.period = this.time&#x2F;count;

        &#x2F;&#x2F; Do we need to do another run?
        this.running = this.time &lt;= this.MIN_TIME;

        &#x2F;&#x2F; ... if so, compute how many times we should iterate
        if (this.running) {
          &#x2F;&#x2F; Bump the count to the nearest power of 2
          var x = this.MIN_TIME&#x2F;this.time;
          var pow = Math.pow(2, Math.max(1, Math.ceil(Math.log(x)&#x2F;Math.log(2))));
          count *= pow;
          if (count &gt; this.MAX_COUNT) {
            throw new Error(&#x27;Max count exceeded.  If this test uses a looping function, make sure the iteration loop is working properly.&#x27;);
          }
        }
      } catch (e) {
        &#x2F;&#x2F; Exceptions are caught and displayed in the test UI
        this.reset();
        this.error = e;
      }

      &#x2F;&#x2F; Figure out what to do next
      if (this.running) {
        me.run(count);
      } else {
        jsl.status(&#x27;&#x27;);
        me.onStop(me);
      }

      &#x2F;&#x2F; Finish up
      this.onChange(this);
    },

    &#x2F;**
    * Get the number of operations per second for this test.
    *
    * @param normalize if true, iteration loop overhead taken into account
    *&#x2F;
    getHz: function(&#x2F;**Boolean*&#x2F; normalize) {
      var p = this.period;

      &#x2F;&#x2F; Adjust period based on the calibration test time
      if (normalize &amp;&amp; !this.isCalibration) {
        var cal = Test.CALIBRATIONS[this.loopArg ? 0 : 1];

        &#x2F;&#x2F; If the period is within 20% of the calibration time, then zero the
        &#x2F;&#x2F; it out
        p = p &lt; cal.period*1.2 ? 0 : p - cal.period;
      }

      return Math.round(1&#x2F;p);
    },

    &#x2F;**
    * Get a friendly string describing the test
    *&#x2F;
    toString: function() {
      return this.name + &#x27; - &#x27;  + this.time&#x2F;this.count + &#x27; secs&#x27;;
    }
  });

  &#x2F;&#x2F; CSS we need for the UI
  var STYLESHEET = &#x27;&lt;style&gt; \
    #jslitmus {font-family:sans-serif; font-size: 12px;} \
    #jslitmus a {text-decoration: none;} \
    #jslitmus a:hover {text-decoration: underline;} \
    #jsl_status { \
      margin-top: 10px; \
      font-size: 10px; \
      color: #888; \
    } \
    A IMG  {border:none} \
    #test_results { \
      margin-top: 10px; \
      font-size: 12px; \
      font-family: sans-serif; \
      border-collapse: collapse; \
      border-spacing: 0px; \
    } \
    #test_results th, #test_results td { \
      border: solid 1px #ccc; \
      vertical-align: top; \
      padding: 3px; \
    } \
    #test_results th { \
      vertical-align: bottom; \
      background-color: #ccc; \
      padding: 1px; \
      font-size: 10px; \
    } \
    #test_results #test_platform { \
      color: #444; \
      text-align:center; \
    } \
    #test_results .test_row { \
      color: #006; \
      cursor: pointer; \
    } \
    #test_results .test_nonlooping { \
      border-left-style: dotted; \
      border-left-width: 2px; \
    } \
    #test_results .test_looping { \
      border-left-style: solid; \
      border-left-width: 2px; \
    } \
    #test_results .test_name {white-space: nowrap;} \
    #test_results .test_pending { \
    } \
    #test_results .test_running { \
      font-style: italic; \
    } \
    #test_results .test_done {} \
    #test_results .test_done { \
      text-align: right; \
      font-family: monospace; \
    } \
    #test_results .test_error {color: #600;} \
    #test_results .test_error .error_head {font-weight:bold;} \
    #test_results .test_error .error_body {font-size:85%;} \
    #test_results .test_row:hover td { \
      background-color: #ffc; \
      text-decoration: underline; \
    } \
    #chart { \
      margin: 10px 0px; \
      width: 250px; \
    } \
    #chart img { \
      border: solid 1px #ccc; \
      margin-bottom: 5px; \
    } \
    #chart #tiny_url { \
      height: 40px; \
      width: 250px; \
    } \
    #jslitmus_credit { \
      font-size: 10px; \
      color: #888; \
      margin-top: 8px; \
    } \
    &lt;&#x2F;style&gt;&#x27;;

  &#x2F;&#x2F; HTML markup for the UI
  var MARKUP = &#x27;&lt;div id=&quot;jslitmus&quot;&gt; \
      &lt;button onclick=&quot;JSLitmus.runAll(event)&quot;&gt;Run Tests&lt;&#x2F;button&gt; \
      &lt;button id=&quot;stop_button&quot; disabled=&quot;disabled&quot; onclick=&quot;JSLitmus.stop()&quot;&gt;Stop Tests&lt;&#x2F;button&gt; \
      &lt;br \&gt; \
      &lt;br \&gt; \
      &lt;input type=&quot;checkbox&quot; style=&quot;vertical-align: middle&quot; id=&quot;test_normalize&quot; checked=&quot;checked&quot; onchange=&quot;JSLitmus.renderAll()&quot;&quot;&gt; Normalize results \
      &lt;table id=&quot;test_results&quot;&gt; \
        &lt;colgroup&gt; \
          &lt;col &#x2F;&gt; \
          &lt;col width=&quot;100&quot; &#x2F;&gt; \
        &lt;&#x2F;colgroup&gt; \
        &lt;tr&gt;&lt;th id=&quot;test_platform&quot; colspan=&quot;2&quot;&gt;&#x27; + platform + &#x27;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt; \
        &lt;tr&gt;&lt;th&gt;Test&lt;&#x2F;th&gt;&lt;th&gt;Ops&#x2F;sec&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt; \
        &lt;tr id=&quot;test_row_template&quot; class=&quot;test_row&quot; style=&quot;display:none&quot;&gt; \
          &lt;td class=&quot;test_name&quot;&gt;&lt;&#x2F;td&gt; \
          &lt;td class=&quot;test_result&quot;&gt;Ready&lt;&#x2F;td&gt; \
        &lt;&#x2F;tr&gt; \
      &lt;&#x2F;table&gt; \
      &lt;div id=&quot;jsl_status&quot;&gt;&lt;&#x2F;div&gt; \
      &lt;div id=&quot;chart&quot; style=&quot;display:none&quot;&gt; \
      &lt;a id=&quot;chart_link&quot; target=&quot;_blank&quot;&gt;&lt;img id=&quot;chart_image&quot;&gt;&lt;&#x2F;a&gt; \
      TinyURL (for chart): \
      &lt;iframe id=&quot;tiny_url&quot; frameBorder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;&quot;&gt;&lt;&#x2F;iframe&gt; \
      &lt;&#x2F;div&gt; \
      &lt;a id=&quot;jslitmus_credit&quot; title=&quot;JSLitmus home page&quot; href=&quot;http:&#x2F;&#x2F;code.google.com&#x2F;p&#x2F;jslitmus&quot; target=&quot;_blank&quot;&gt;Powered by JSLitmus&lt;&#x2F;a&gt; \
    &lt;&#x2F;div&gt;&#x27;;

  &#x2F;**
   * The public API for creating and running tests
   *&#x2F;
  window.JSLitmus = {
    &#x2F;** The list of all tests that have been registered with JSLitmus.test *&#x2F;
    _tests: [],
    &#x2F;** The queue of tests that need to be run *&#x2F;
    _queue: [],

    &#x2F;**
    * The parsed query parameters the current page URL.  This is provided as a
    * convenience for test functions - it&#x27;s not used by JSLitmus proper
    *&#x2F;
    params: {},

    &#x2F;**
     * Initialize
     *&#x2F;
    _init: function() {
      &#x2F;&#x2F; Parse query params into JSLitmus.params[] hash
      var match = (location + &#x27;&#x27;).match(&#x2F;([^?#]*)(#.*)?$&#x2F;);
      if (match) {
        var pairs = match[1].split(&#x27;&amp;&#x27;);
        for (var i = 0; i &lt; pairs.length; i++) {
          var pair = pairs[i].split(&#x27;=&#x27;);
          if (pair.length &gt; 1) {
            var key = pair.shift();
            var value = pair.length &gt; 1 ? pair.join(&#x27;=&#x27;) : pair[0];
            this.params[key] = value;
          }
        }
      }

      &#x2F;&#x2F; Write out the stylesheet.  We have to do this here because IE
      &#x2F;&#x2F; doesn&#x27;t honor sheets written after the document has loaded.
      document.write(STYLESHEET);

      &#x2F;&#x2F; Setup the rest of the UI once the document is loaded
      if (window.addEventListener) {
        window.addEventListener(&#x27;load&#x27;, this._setup, false);
      } else if (document.addEventListener) {
        document.addEventListener(&#x27;load&#x27;, this._setup, false);
      } else if (window.attachEvent) {
        window.attachEvent(&#x27;onload&#x27;, this._setup);
      }

      return this;
    },

    &#x2F;**
     * Set up the UI
     *&#x2F;
    _setup: function() {
      var el = jsl.$(&#x27;jslitmus_container&#x27;);
      if (!el) document.body.appendChild(el = document.createElement(&#x27;div&#x27;));

      el.innerHTML = MARKUP;

      &#x2F;&#x2F; Render the UI for all our tests
      for (var i=0; i &lt; JSLitmus._tests.length; i++)
        JSLitmus.renderTest(JSLitmus._tests[i]);
    },

    &#x2F;**
     * (Re)render all the test results
     *&#x2F;
    renderAll: function() {
      for (var i = 0; i &lt; JSLitmus._tests.length; i++)
        JSLitmus.renderTest(JSLitmus._tests[i]);
      JSLitmus.renderChart();
    },

    &#x2F;**
     * (Re)render the chart graphics
     *&#x2F;
    renderChart: function() {
      var url = JSLitmus.chartUrl();
      jsl.$(&#x27;chart_link&#x27;).href = url;
      jsl.$(&#x27;chart_image&#x27;).src = url;
      jsl.$(&#x27;chart&#x27;).style.display = &#x27;&#x27;;

      &#x2F;&#x2F; Update the tiny URL
      jsl.$(&#x27;tiny_url&#x27;).src = &#x27;http:&#x2F;&#x2F;tinyurl.com&#x2F;api-create.php?url=&#x27;+escape(url);
    },

    &#x2F;**
     * (Re)render the results for a specific test
     *&#x2F;
    renderTest: function(test) {
      &#x2F;&#x2F; Make a new row if needed
      if (!test._row) {
        var trow = jsl.$(&#x27;test_row_template&#x27;);
        if (!trow) return;

        test._row = trow.cloneNode(true);
        test._row.style.display = &#x27;&#x27;;
        test._row.id = &#x27;&#x27;;
        test._row.onclick = function() {JSLitmus._queueTest(test);};
        test._row.title = &#x27;Run &#x27; + test.name + &#x27; test&#x27;;
        trow.parentNode.appendChild(test._row);
        test._row.cells[0].innerHTML = test.name;
      }

      var cell = test._row.cells[1];
      var cns = [test.loopArg ? &#x27;test_looping&#x27; : &#x27;test_nonlooping&#x27;];

      if (test.error) {
        cns.push(&#x27;test_error&#x27;);
        cell.innerHTML =
        &#x27;&lt;div class=&quot;error_head&quot;&gt;&#x27; + test.error + &#x27;&lt;&#x2F;div&gt;&#x27; +
        &#x27;&lt;ul class=&quot;error_body&quot;&gt;&lt;li&gt;&#x27; +
          jsl.join(test.error, &#x27;: &#x27;, &#x27;&lt;&#x2F;li&gt;&lt;li&gt;&#x27;) +
          &#x27;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#x27;;
      } else {
        if (test.running) {
          cns.push(&#x27;test_running&#x27;);
          cell.innerHTML = &#x27;running&#x27;;
        } else if (jsl.indexOf(JSLitmus._queue, test) &gt;= 0) {
          cns.push(&#x27;test_pending&#x27;);
          cell.innerHTML = &#x27;pending&#x27;;
        } else if (test.count) {
          cns.push(&#x27;test_done&#x27;);
          var hz = test.getHz(jsl.$(&#x27;test_normalize&#x27;).checked);
          cell.innerHTML = hz != Infinity ? hz : &#x27;&amp;infin;&#x27;;
          cell.title = &#x27;Looped &#x27; + test.count + &#x27; times in &#x27; + test.time + &#x27; seconds&#x27;;
        } else {
          cell.innerHTML = &#x27;ready&#x27;;
        }
      }
      cell.className = cns.join(&#x27; &#x27;);
    },

    &#x2F;**
     * Create a new test
     *&#x2F;
    test: function(name, f) {
      &#x2F;&#x2F; Create the Test object
      var test = new Test(name, f);
      JSLitmus._tests.push(test);

      &#x2F;&#x2F; Re-render if the test state changes
      test.onChange = JSLitmus.renderTest;

      &#x2F;&#x2F; Run the next test if this one finished
      test.onStop = function(test) {
        if (JSLitmus.onTestFinish) JSLitmus.onTestFinish(test);
        JSLitmus.currentTest = null;
        JSLitmus._nextTest();
      };

      &#x2F;&#x2F; Render the new test
      this.renderTest(test);
    },

    &#x2F;**
     * Add all tests to the run queue
     *&#x2F;
    runAll: function(e) {
      e = e || window.event;
      var reverse = e &amp;&amp; e.shiftKey, len = JSLitmus._tests.length;
      for (var i = 0; i &lt; len; i++) {
        JSLitmus._queueTest(JSLitmus._tests[!reverse ? i : (len - i - 1)]);
      }
    },

    &#x2F;**
     * Remove all tests from the run queue.  The current test has to finish on
     * it&#x27;s own though
     *&#x2F;
    stop: function() {
      while (JSLitmus._queue.length) {
        var test = JSLitmus._queue.shift();
        JSLitmus.renderTest(test);
      }
    },

    &#x2F;**
     * Run the next test in the run queue
     *&#x2F;
    _nextTest: function() {
      if (!JSLitmus.currentTest) {
        var test = JSLitmus._queue.shift();
        if (test) {
          jsl.$(&#x27;stop_button&#x27;).disabled = false;
          JSLitmus.currentTest = test;
          test.run();
          JSLitmus.renderTest(test);
          if (JSLitmus.onTestStart) JSLitmus.onTestStart(test);
        } else {
          jsl.$(&#x27;stop_button&#x27;).disabled = true;
          JSLitmus.renderChart();
        }
      }
    },

    &#x2F;**
     * Add a test to the run queue
     *&#x2F;
    _queueTest: function(test) {
      if (jsl.indexOf(JSLitmus._queue, test) &gt;= 0) return;
      JSLitmus._queue.push(test);
      JSLitmus.renderTest(test);
      JSLitmus._nextTest();
    },

    &#x2F;**
     * Generate a Google Chart URL that shows the data for all tests
     *&#x2F;
    chartUrl: function() {
      var n = JSLitmus._tests.length, markers = [], data = [];
      var d, min = 0, max = -1e10;
      var normalize = jsl.$(&#x27;test_normalize&#x27;).checked;

      &#x2F;&#x2F; Gather test data
      for (var i=0; i &lt; JSLitmus._tests.length; i++) {
        var test = JSLitmus._tests[i];
        if (test.count) {
          var hz = test.getHz(normalize);
          var v = hz != Infinity ? hz : 0;
          data.push(v);
          markers.push(&#x27;t&#x27; + jsl.escape(test.name + &#x27;(&#x27; + jsl.toLabel(hz)+ &#x27;)&#x27;) + &#x27;,000000,0,&#x27; +
            markers.length + &#x27;,10&#x27;);
          max = Math.max(v, max);
        }
      }
      if (markers.length &lt;= 0) return null;

      &#x2F;&#x2F; Build chart title
      var title = document.getElementsByTagName(&#x27;title&#x27;);
      title = (title &amp;&amp; title.length) ? title[0].innerHTML : null;
      var chart_title = [];
      if (title) chart_title.push(title);
      chart_title.push(&#x27;Ops&#x2F;sec (&#x27; + platform + &#x27;)&#x27;);

      &#x2F;&#x2F; Build labels
      var labels = [jsl.toLabel(min), jsl.toLabel(max)];

      var w = 250, bw = 15;
      var bs = 5;
      var h = markers.length*(bw + bs) + 30 + chart_title.length*20;

      var params = {
        chtt: escape(chart_title.join(&#x27;|&#x27;)),
        chts: &#x27;000000,10&#x27;,
        cht: &#x27;bhg&#x27;,                     &#x2F;&#x2F; chart type
        chd: &#x27;t:&#x27; + data.join(&#x27;,&#x27;),     &#x2F;&#x2F; data set
        chds: min + &#x27;,&#x27; + max,          &#x2F;&#x2F; max&#x2F;min of data
        chxt: &#x27;x&#x27;,                      &#x2F;&#x2F; label axes
        chxl: &#x27;0:|&#x27; + labels.join(&#x27;|&#x27;), &#x2F;&#x2F; labels
        chsp: &#x27;0,1&#x27;,
        chm: markers.join(&#x27;|&#x27;),         &#x2F;&#x2F; test names
        chbh: [bw, 0, bs].join(&#x27;,&#x27;),    &#x2F;&#x2F; bar widths
        &#x2F;&#x2F; chf: &#x27;bg,lg,0,eeeeee,0,eeeeee,.5,ffffff,1&#x27;, &#x2F;&#x2F; gradient
        chs: w + &#x27;x&#x27; + h
      };
      return &#x27;http:&#x2F;&#x2F;chart.apis.google.com&#x2F;chart?&#x27; + jsl.join(params, &#x27;=&#x27;, &#x27;&amp;&#x27;);
    }
  };

  JSLitmus._init();
})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
