#!/usr/bin/env node

const path = require( 'path' );
const fs = require( 'fs' );

function stat ( file ) {
	try {
		return fs.statSync( file );
	} catch ( e ) {}
}

function readToString ( stream ) {
	return new Promise( ( ok, fail ) => {
		const data = [];
		stream.on( 'data', chunk => data.push( chunk ) );
		stream.on( 'end', () => ok( Buffer.concat( data ).toString( 'utf8' ) ) );
		stream.on( 'error', fail );
	});
}

// find Ractive
const basePath = path.resolve( path.dirname( fs.realpathSync( __filename ) ) );
const devFile = path.resolve( basePath, '../build/ractive.js' );
const modFile = path.resolve( basePath, '../ractive.js' );
const Ractive = require( stat( modFile ) ? modFile : devFile );

const parse = require( './lib/parse' );
const component = require( './lib/component' );

const args = process.argv.slice();

if ( ~args[0].indexOf( 'node' ) ) args.shift();
const program = args.shift();
const cmd = args.shift();

let input = process.stdin;
let output = process.stdout;
// base path for resolving paths
let base = process.cwd();

let arg;
const opts = {};

switch ( cmd ) {
	case 'parse':
		while ( arg = args.shift() ) {
			switch ( arg ) {
				case '-i':
				case '--input':
					input = fs.createReadStream( args.shift() );
					break;

				case '-o':
				case '--output':
					output = fs.createWriteStream( args.shift() );
					break;

				case '-t':
				case '--text-only':
					opts.textOnlyMode = true;
					break;

				case '-x':
				case '--nocsp':
					opts.csp = false;
					break;

				case '-d':
				case '--delimiters':
					opts.delimiters = [ args.shift(), args.shift() ];
					break;

				case '-s':
				case '--static':
					opts.staticDelimiters = [ args.shift(), args.shift() ];
					break;

				case '-r':
				case '--triple':
					opts.tripleDelimiters = [ args.shift(), args.shift() ];
					break;

				case '-p':
				case '--static-triple':
					opts.staticTripleDelimiters = [ args.shift(), args.shift() ];
					break;

				default:
					console.error( '??? ', arg );
					break;
			}
		}
		readToString( input ).then( string => {
			parse.parse( Ractive, string, output, opts );
		}, err => {
			console.error( err.message );
			process.exit( 1 );
		});
		break;

	case 'component':
		while ( arg = args.shift() ) {
			switch ( arg ) {
				case '-i':
				case '--input':
					const file = args.shift();
					const stats = stat( file );
					if ( stats && stats.isDirectory() ) {
						base = file;
						if ( stat( path.resolve( file, './index.ractive' ) ) ) {
							input = fs.createReadStream( path.resolve( file, './index.ractive' ) );
						} else {
							input = fs.createReadStream( path.resolve( file, './index.html' ) );
						}
					} else {
						base = path.dirname( file );
						input = fs.createReadStream( file );
					}
					break;

				case '-o':
				case '--output':
					output = fs.createWriteStream( args.shift() );
					break;

				case '-x':
				case '--nocsp':
					opts.csp = false;
					break;

				case '-d':
				case '--delimiters':
					opts.delimiters = [ args.shift(), args.shift() ];
					break;

				case '-s':
				case '--static':
					opts.staticDelimiters = [ args.shift(), args.shift() ];
					break;

				case '-r':
				case '--triple':
					opts.tripleDelimiters = [ args.shift(), args.shift() ];
					break;

				case '-p':
				case '--static-triple':
					opts.staticTripleDelimiters = [ args.shift(), args.shift() ];
					break;

				defatult:
					console.error( '??? ', arg );
					break;
			}
		}
		readToString( input ).then( string => {
			component.build( Ractive, string, output, opts, base );
		}, err => {
			console.error( err.message );
			process.exit( 1 );
		});
		break;

	default:
		console.error( `Usage: ractive [command] [options]\n  Commands:` );
		console.error( parse.help );
		console.error( component.help );
		process.exit( 1 );
}
